package Interpreter.Lexer;

import Interpreter.Lexer.Token.Token;
import Interpreter.Lexer.Token.TokenType;

import java.util.ArrayList;
import java.util.List;

public class Lexer {
    private String expression;

    public Lexer(String expression) {
        this.expression = expression;
    }


    /**
     * Returns an entire List of Tokens, generated by the |expression|'s characters.
     * @return A new list of tokens.
     * @throws NumberFormatException Thrown if a double contains more than one period
     * @throws NoSuchFieldException Thrown if a name contains a bad character (i.e. %)
     */
    public List<Token> getTokenList() throws NumberFormatException, NoSuchFieldException{
        List<Token> tokens = new ArrayList<>(); //List of tokens to be added to

        for(int i = 0; i < expression.length(); i++){ //We're going to loop through all of the characters in the string
            TokenType token = getToken(i);
            if(token.equals(TokenType.T_ID)){ //If we hit a ID name...
                String idName = "";
                while(i < expression.length() //While there's a character (or number) continue adding the characters
                        && !getToken(i).equals(TokenType.T_RIGHT_PAREN)
                        && !getToken(i).equals(TokenType.T_LEFT_PAREN)
                        && !getToken(i).equals(TokenType.SPACE)
                        && !getToken(i).equals(TokenType.T_EQUALS)
                        && !getToken(i).equals(TokenType.T_MINUS)
                        && !getToken(i).equals(TokenType.T_PLUS)
                        && !getToken(i).equals(TokenType.T_MUL)
                        && !getToken(i).equals(TokenType.T_DIV)){
                    idName += Character.toString(charAt(i)); //Add the character to the ID name
                    i++; //Continue to the next character to check
                }
                i--; //The last iteration will add one too many, for when the for-loop re-loops through

                if(!contains(idName, "!@#$%^&*()_+=-/\\"))
                    tokens.add(new Token(TokenType.T_ID, idName, 0));
                else
                    throw new NoSuchFieldException(idName);

            }else if(token.equals(TokenType.T_DOUBLE)){ //We know it's a double value
                String doubleValue = "";
                while(i < expression.length() //While there's a character (or number) continue adding the characters
                        && getToken(i).equals(TokenType.T_DOUBLE)){
                    doubleValue += Character.toString(charAt(i)); //Add the character to the double value
                    i++; //Continue to the next character to check
                }
                i--; //The last iteration will add one too many, for when the for-loop re-loops through

                if(count(doubleValue, '.') <= 1)
                    tokens.add(new Token(TokenType.T_DOUBLE, doubleValue,
                            Math.round(Double.parseDouble(doubleValue)*1000.0)/1000.0));
                else{
                    throw new NumberFormatException(doubleValue);
                }

            }else if(!token.equals(TokenType.SPACE)){ //We know it's not a double or ID name, we know it's some symbol
                tokens.add(new Token(getToken(i), Character.toString(charAt(i)), 0));
            }
        }

        return tokens;
    }


    /**
     * Returns the TokenType which correlates to each given character at position |i|
     * @param i The position of the character in the string |expression|
     * @return The corresponding TokenType to the character at position |i|
     */
    private TokenType getToken(int i){
        char c = charAt(i);
        if(Character.isAlphabetic(c)){
            return TokenType.T_ID;
        }else if(c == '='){
            return TokenType.T_EQUALS;
        }else if(c == '+'){
            return TokenType.T_PLUS;
        }else if(c == '/'){
            return TokenType.T_DIV;
        }else if(c == '-'){
            return TokenType.T_MINUS;
        }else if(c == '('){
            return TokenType.T_LEFT_PAREN;
        }else if(c == ')'){
            return TokenType.T_RIGHT_PAREN;
        }else if(c == '*'){
            return TokenType.T_MUL;
        }else if(c == '%'){
            return TokenType.T_MODULUS;
        }else if(c == '^') {
            return TokenType.T_POWER;
        }else if(Character.isSpaceChar(c)){
            return TokenType.SPACE;
        }else if(c == '.' || Character.isDigit(c)){
            return TokenType.T_DOUBLE;
        }
        return TokenType.NULL;
    }


    /**
     * Counts the total amount of characters |counter| that are in the String |str|
     * @param str The string we're examining
     * @param counter The character we're counting
     * @return Amount of total counts
     */
    private int count(String str, char counter){
        int count = 0;
        for(Character c : str.toCharArray()){
            if(c == counter)
                count++;
        }
        return count;
    }


    /**
     * Checks a string |str| for all of the characters in the |contains| String for the |contains| characters.
     * If any of the characters match, will return true, else false.
     * @param str The string we're comparing
     * @param contains The characters we're searching for
     * @return True if there is a matching character
     */
    private boolean contains(String str, String contains){
        for(Character c : str.toCharArray()){
            for (Character c2 : contains.toCharArray()){
                if(c2 == c)
                    return true;
            }
        }
        return false;
    }


    /**
     * Gets a character at position |i| in the string
     * @param i The position of the character we want
     * @return A character at position |i|
     */
    private char charAt(int i) {
        return expression.charAt(i);
    }
}